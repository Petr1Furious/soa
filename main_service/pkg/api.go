/*
 * Main Service API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"database/sql"

	"github.com/gorilla/mux"
	_ "github.com/lib/pq"
	"github.com/segmentio/kafka-go"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/protobuf/proto"

	ppb "posts_service/pkg/pb"
	kpb "statistics_service/pkg/kafka_pb"
	spb "statistics_service/pkg/pb"
)

var db *sql.DB

var postGrpcClient ppb.PostServiceClient

var kafkaProducer *kafka.Writer

var statisticsGrpcClient spb.StatisticsServiceClient

func InitGRPC() {
	grpcServerAddr, ok := os.LookupEnv("POSTS_GRPC_SERVER")
	if !ok {
		log.Fatalf("POSTS_GRPC_SERVER not set")
	}
	conn, err := grpc.NewClient(grpcServerAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Failed to connect to gRPC server: %v", err)
	}
	postGrpcClient = ppb.NewPostServiceClient(conn)

	grpcServerAddr, ok = os.LookupEnv("STATISTICS_GRPC_SERVER")
	if !ok {
		log.Fatalf("STATISTICS_GRPC_SERVER not set")
	}
	conn, err = grpc.NewClient(grpcServerAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Failed to connect to gRPC server: %v", err)
	}
	statisticsGrpcClient = spb.NewStatisticsServiceClient(conn)
}

func InitKafka() {
	kafkaAddr, ok := os.LookupEnv("KAFKA_SERVER")
	if !ok {
		log.Fatalf("KAFKA_SERVER not set")
	}
	kafkaProducer = kafka.NewWriter(kafka.WriterConfig{
		Brokers: []string{kafkaAddr},
		Topic:   "my-topic",
		Logger:  log.New(os.Stdout, "kafka writer: ", 0),
	})
}

func Init() {
	InitGRPC()
	InitKafka()

	var err error
	host, ok := os.LookupEnv("MAIN_DB_HOST")
	if !ok {
		log.Fatalf("MAIN_DB_HOST not set")
	}
	username, ok := os.LookupEnv("MAIN_DB_USERNAME")
	if !ok {
		log.Fatalf("MAIN_DB_USERNAME not set")
	}
	password, ok := os.LookupEnv("MAIN_DB_PASSWORD")
	if !ok {
		log.Fatalf("MAIN_DB_PASSWORD not set")
	}
	dbname, ok := os.LookupEnv("MAIN_DB_NAME")
	if !ok {
		log.Fatalf("MAIN_DB_NAME not set")
	}

	db, err = sql.Open("postgres", fmt.Sprintf("host=%s user=%s password=%s dbname=%s sslmode=disable", host, username, password, dbname))
	if err != nil {
		log.Fatalf("Error opening database: %v", err)
	}

	for i := 0; i < 5; i++ {
		_, err = db.Exec(`CREATE TABLE IF NOT EXISTS users (
        login TEXT NOT NULL,
        password TEXT NOT NULL,
        first_name TEXT,
        last_name TEXT,
        birth_date DATE,
        email TEXT,
        phone_number TEXT
    )`)
		if err == nil {
			break
		}
		log.Printf("Error creating table: %v", err)
		if i < 4 {
			time.Sleep(time.Second * time.Duration(i+1))
		}
	}

	if err != nil {
		log.Fatalf("Error creating table: %v", err)
	}

	_, err = db.Exec(`CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY,
        user_id TEXT NOT NULL,
        created_at TIMESTAMP NOT NULL,
        expires_at TIMESTAMP NOT NULL
    )`)
	if err != nil {
		log.Fatalf("Error creating table: %v", err)
	}

	_, err = db.Exec("DELETE FROM sessions WHERE expires_at < $1", time.Now())
	if err != nil {
		log.Fatalf("Error cleaning up expired sessions: %v", err)
	}

	fmt.Println("Database initialized")
}

func generateSessionID() (string, error) {
	sessionID := make([]byte, 32)
	_, err := rand.Read(sessionID)
	if err != nil {
		return "", err
	}
	return hex.EncodeToString(sessionID), nil
}

func ReadBody(w http.ResponseWriter, r *http.Request) ([]byte, bool) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	body := make([]byte, r.ContentLength)
	read, err := r.Body.Read(body)
	defer r.Body.Close()
	if read != int(r.ContentLength) {
		w.WriteHeader(http.StatusBadRequest)
		return nil, false
	}
	if err != io.EOF {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "Error reading body: %v", err)
		return nil, false
	}
	return body, true
}

func AuthPost(w http.ResponseWriter, r *http.Request) {
	body, ok := ReadBody(w, r)
	if !ok {
		return
	}

	auth := AuthBody{}
	err := json.Unmarshal(body, &auth)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Error unmarshaling body: %v", err)
		return
	}

	if auth.Login == "" || auth.Password == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Login and password are required")
		return
	}

	var dbPassword string
	err = db.QueryRow("SELECT password FROM users WHERE login = $1", auth.Login).Scan(&dbPassword)
	if err != nil {
		if err == sql.ErrNoRows {
			w.WriteHeader(http.StatusUnauthorized)
			fmt.Fprintf(w, "Invalid login or password")
		} else {
			w.WriteHeader(http.StatusInternalServerError)
			fmt.Fprintf(w, "Error querying the database: %v", err)
		}
		return
	}

	hasher := sha256.New()
	hasher.Write([]byte(auth.Login + auth.Password))
	hashedPassword := hex.EncodeToString(hasher.Sum(nil))

	if hashedPassword != dbPassword {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "Invalid login or password")
		return
	}

	sessionID, err := generateSessionID()
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "Error generating session ID: %v", err)
		return
	}

	_, err = db.Exec("INSERT INTO sessions(id, user_id, created_at, expires_at) VALUES($1, $2, $3, $4)",
		sessionID, auth.Login, time.Now(), time.Now().Add(24*time.Hour))
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "Error writing to database: %v", err)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:     "SESSIONID",
		Value:    sessionID,
		Expires:  time.Now().Add(24 * time.Hour),
		HttpOnly: true,
	})
	w.WriteHeader(http.StatusOK)
}

func getUserSessionID(sessionID string) (string, error) {
	var userID string
	err := db.QueryRow("SELECT user_id FROM sessions WHERE id = $1 AND expires_at > $2", sessionID, time.Now()).Scan(&userID)
	if err != nil {
		return "", err
	}
	return userID, nil
}

func checkAuthAndGetUserID(w http.ResponseWriter, r *http.Request) (string, bool) {
	sessionID, err := r.Cookie("SESSIONID")
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "Not authenticated")
		return "", false
	}

	userID, err := getUserSessionID(sessionID.Value)
	if err != nil {
		w.WriteHeader(http.StatusUnauthorized)
		fmt.Fprintf(w, "Not authenticated")
		return "", false
	}

	return userID, true
}

func UsersMePatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	userID, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	body, ok := ReadBody(w, r)
	if !ok {
		return
	}

	user := UsersMeBody{}
	err := json.Unmarshal(body, &user)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Error unmarshaling body: %v", err)
		return
	}

	query := "UPDATE users SET"
	params := []interface{}{}
	paramID := 1

	if user.FirstName != "" {
		query += fmt.Sprintf(" first_name = $%d,", paramID)
		params = append(params, user.FirstName)
		paramID++
	}

	if user.LastName != "" {
		query += fmt.Sprintf(" last_name = $%d,", paramID)
		params = append(params, user.LastName)
		paramID++
	}

	if user.BirthDate != "" {
		query += fmt.Sprintf(" birth_date = $%d,", paramID)
		params = append(params, user.BirthDate)
		paramID++
	}

	if user.Email != "" {
		query += fmt.Sprintf(" email = $%d,", paramID)
		params = append(params, user.Email)
		paramID++
	}

	if user.PhoneNumber != "" {
		query += fmt.Sprintf(" phone_number = $%d,", paramID)
		params = append(params, user.PhoneNumber)
		paramID++
	}

	query = query[:len(query)-1] + fmt.Sprintf(" WHERE login = $%d", paramID)
	params = append(params, userID)

	_, err = db.Exec(query, params...)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "Error updating user: %v", err)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func UsersPost(w http.ResponseWriter, r *http.Request) {
	body, ok := ReadBody(w, r)
	if !ok {
		return
	}

	user := UsersBody{}
	err := json.Unmarshal(body, &user)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Error unmarshaling body: %v", err)
		return
	}

	if user.Login == "" || user.Password == "" {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Login and password are required")
		return
	}

	var count int
	err = db.QueryRow("SELECT COUNT(*) FROM users WHERE login = $1", user.Login).Scan(&count)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "Error querying the database: %v", err)
		return
	}

	if count > 0 {
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "User with login %s already exists", user.Login)
		return
	}

	hasher := sha256.New()
	hasher.Write([]byte(user.Login + user.Password))
	hashedPassword := hex.EncodeToString(hasher.Sum(nil))

	_, err = db.Exec("INSERT INTO users(login, password) VALUES($1, $2)", user.Login, hashedPassword)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprintf(w, "Error writing to database: %v", err)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func PostsGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	userID, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	params := r.URL.Query()
	pageStr := params.Get("page")
	page, err := strconv.Atoi(pageStr)
	if err != nil {
		http.Error(w, "Invalid page number", http.StatusBadRequest)
		return
	}
	pageSizeStr := params.Get("pageSize")
	pageSize, err := strconv.Atoi(pageSizeStr)
	if err != nil {
		http.Error(w, "Invalid page size", http.StatusBadRequest)
		return
	}

	var createPostRequest = &ppb.ListPostsRequest{
		UserId:   userID,
		Page:     int32(page),
		PageSize: int32(pageSize),
	}
	resp, err := postGrpcClient.ListPosts(r.Context(), createPostRequest)
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	respBytes, err := json.Marshal(resp)
	if err != nil {
		http.Error(w, "Error marshaling response", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	w.Write(respBytes)
}

func PostsPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	userID, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	body, ok := ReadBody(w, r)
	if !ok {
		return
	}

	var content string
	err := json.Unmarshal(body, &content)
	if err != nil {
		http.Error(w, "Error unmarshaling body", http.StatusBadRequest)
		return
	}

	var createPostRequest = &ppb.CreatePostRequest{
		Content: content,
		UserId:  userID,
	}
	resp, err := postGrpcClient.CreatePost(r.Context(), createPostRequest)
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	respBytes, err := json.Marshal(resp)
	if err != nil {
		http.Error(w, "Error marshaling response", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	w.Write(respBytes)
}

func PostsPostIdGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	_, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	vars := mux.Vars(r)
	postID := vars["postId"]

	var getPostRequest = &ppb.GetPostRequest{
		PostId: postID,
	}
	resp, err := postGrpcClient.GetPost(r.Context(), getPostRequest)
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	respBytes, err := json.Marshal(resp)
	if err != nil {
		http.Error(w, "Error marshaling response", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	w.Write(respBytes)
}

func PostsPostIdDelete(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	userID, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	vars := mux.Vars(r)
	postID := vars["postId"]

	var deletePostRequest = &ppb.DeletePostRequest{
		UserId: userID,
		PostId: postID,
	}
	_, err := postGrpcClient.DeletePost(r.Context(), deletePostRequest)
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func PostsPostIdPatch(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	userID, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	body, ok := ReadBody(w, r)
	if !ok {
		return
	}

	var content string
	err := json.Unmarshal(body, &content)
	if err != nil {
		http.Error(w, "Error unmarshaling body", http.StatusBadRequest)
		return
	}

	vars := mux.Vars(r)
	postID := vars["postId"]

	var updatePostRequest = &ppb.UpdatePostRequest{
		UserId:  userID,
		PostId:  postID,
		Content: content,
	}
	resp, err := postGrpcClient.UpdatePost(r.Context(), updatePostRequest)
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	respBytes, err := json.Marshal(resp)
	if err != nil {
		http.Error(w, "Error marshaling response", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	w.Write(respBytes)
}

func PostsPostIdViewPost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	userID, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	vars := mux.Vars(r)
	postID := vars["postId"]

	post, err := postGrpcClient.GetPost(r.Context(), &ppb.GetPostRequest{PostId: postID})
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}
	authorID := post.UserId

	viewEvent := &kpb.Event_ViewEvent{
		ViewEvent: &kpb.ViewEvent{
			UserId:   userID,
			PostId:   postID,
			AuthorId: authorID,
		},
	}
	event := &kpb.Event{
		EventType: viewEvent,
	}
	msg, err := proto.Marshal(event)
	if err != nil {
		http.Error(w, "Error marshaling view message", http.StatusInternalServerError)
		return
	}

	err = kafkaProducer.WriteMessages(r.Context(), kafka.Message{
		Value: msg,
	})
	if err != nil {
		http.Error(w, "Kafka: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func PostsPostIdLikePost(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	userID, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	vars := mux.Vars(r)
	postID := vars["postId"]

	post, err := postGrpcClient.GetPost(r.Context(), &ppb.GetPostRequest{PostId: postID})
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}
	authorID := post.UserId

	likeEvent := &kpb.Event_LikeEvent{
		LikeEvent: &kpb.LikeEvent{
			UserId:   userID,
			PostId:   postID,
			AuthorId: authorID,
		},
	}
	event := &kpb.Event{
		EventType: likeEvent,
	}
	msg, err := proto.Marshal(event)
	if err != nil {
		http.Error(w, "Error marshaling like message", http.StatusInternalServerError)
		return
	}

	err = kafkaProducer.WriteMessages(r.Context(), kafka.Message{
		Value: msg,
	})
	if err != nil {
		http.Error(w, "Kafka: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func GetPostStats(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	_, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	vars := mux.Vars(r)
	postID := vars["postId"]

	resp, err := statisticsGrpcClient.GetPostStats(r.Context(), &spb.PostStatsRequest{PostId: postID})
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	postStats := PostStats{
		Id:        postID,
		ViewCount: resp.ViewCount,
		LikeCount: resp.LikeCount,
	}

	respBytes, err := json.Marshal(postStats)
	if err != nil {
		http.Error(w, "Error marshaling response", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	w.Write(respBytes)
}

func getUserNameFromDB(userID string) (string, error) {
	var firstName, lastName sql.NullString
	query := `SELECT first_name, last_name FROM users WHERE login = $1`
	err := db.QueryRow(query, userID).Scan(&firstName, &lastName)
	if err != nil {
		return "", fmt.Errorf("could not get author name: %v", err)
	}
	var authorName string
	if firstName.Valid && lastName.Valid {
		authorName = firstName.String + " " + lastName.String
	} else if firstName.Valid {
		authorName = firstName.String
	} else if lastName.Valid {
		authorName = lastName.String
	}
	return authorName, nil
}

func GetTopPosts(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	_, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	sortBy := r.URL.Query().Get("sortBy")

	resp, err := statisticsGrpcClient.GetTopPosts(r.Context(), &spb.TopPostsRequest{Type: sortBy})
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	topPosts := make([]TopPost, len(resp.Posts))
	for i, post := range resp.Posts {
		authorName, err := getUserNameFromDB(post.AuthorId)
		if err != nil {
			http.Error(w, "Error getting author name: "+err.Error(), http.StatusInternalServerError)
			return
		}
		topPosts[i] = TopPost{
			Id:         post.Id,
			AuthorName: authorName,
			Count:      post.Count,
		}
	}

	respBytes, err := json.Marshal(topPosts)
	if err != nil {
		http.Error(w, "Error marshaling response", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	w.Write(respBytes)
}

func GetTopUsers(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	_, ok := checkAuthAndGetUserID(w, r)
	if !ok {
		return
	}

	resp, err := statisticsGrpcClient.GetTopUsers(r.Context(), &spb.TopUsersRequest{})
	if err != nil {
		http.Error(w, "gRPC: "+err.Error(), http.StatusInternalServerError)
		return
	}

	topUsers := make([]TopUser, len(resp.Users))
	for i, user := range resp.Users {
		name, err := getUserNameFromDB(user.Id)
		if err != nil {
			http.Error(w, "Error getting user name: "+err.Error(), http.StatusInternalServerError)
			return
		}
		topUsers[i] = TopUser{
			Name:       name,
			LikesCount: user.LikesCount,
		}
	}

	respBytes, err := json.Marshal(topUsers)
	if err != nil {
		http.Error(w, "Error marshaling response", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	w.Write(respBytes)
}
